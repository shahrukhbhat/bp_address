"use strict";
/*!
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyFiles = exports.findConflicts = exports.getCopyDescriptors = exports.getTemplatePaths = void 0;
const fs = require("fs");
const handlebars_1 = require("handlebars");
const https = require("https");
const path = require("path");
const templatesDir = path.resolve(__dirname, '../templates');
function getTemplatePathsForDir(inputDir, excludes) {
    const directoryEntries = fs.readdirSync(path.resolve(templatesDir, ...inputDir), { withFileTypes: true });
    return directoryEntries.reduce((templates, directoryEntry) => {
        if (directoryEntry.isDirectory() && !excludes.includes(directoryEntry.name)) {
            return [...templates, ...getTemplatePathsForDir([...inputDir, directoryEntry.name], excludes)];
        }
        if (directoryEntry.isFile() && !excludes.includes(directoryEntry.name)) {
            return [...templates, path.resolve(templatesDir, ...inputDir, directoryEntry.name)];
        }
        return templates;
    }, []);
}
function getTemplatePaths(inputDirs, excludes = []) {
    return inputDirs.reduce((templatePaths, inputDir) => (Object.assign(Object.assign({}, templatePaths), { [inputDir]: getTemplatePathsForDir([inputDir], excludes) })), {});
}
exports.getTemplatePaths = getTemplatePaths;
function getCopyDescriptorForPath(targetDir, templateSubDir, templatePath) {
    const relativeSourcePath = path.relative(path.resolve(templatesDir, templateSubDir), path.dirname(templatePath));
    const targetTemplateDir = path.resolve(targetDir, relativeSourcePath);
    return {
        sourcePath: templatePath,
        fileName: path.resolve(targetTemplateDir, path.basename(templatePath, '.mu'))
    };
}
function getCopyDescriptors(targetDir, templatePaths) {
    return Object.entries(templatePaths).reduce((allCopyDescriptors, [templateSubDir, paths]) => [
        ...allCopyDescriptors,
        ...paths.map(path => getCopyDescriptorForPath(targetDir, templateSubDir, path))
    ], []);
}
exports.getCopyDescriptors = getCopyDescriptors;
async function findConflicts(copyDescriptors, force = false) {
    const conflicts = copyDescriptors.filter(copyDescriptor => fs.existsSync(copyDescriptor.fileName));
    if (conflicts.length) {
        if (force) {
            conflicts.forEach(copyDescriptor => fs.unlinkSync(copyDescriptor.fileName));
        }
        else {
            const listOfFiles = conflicts.map(f => path.basename(f.fileName)).join('", "');
            throw new Error(conflicts.length > 1
                ? `Files with the names "${listOfFiles}" already exist. If you want to overwrite them, rerun the command with \`--force\`.`
                : `A file with the name "${listOfFiles}" already exists. If you want to overwrite it, rerun the command with \`--force\`.`);
        }
    }
}
exports.findConflicts = findConflicts;
async function copyFiles(copyDescriptors, options) {
    return Promise.all(copyDescriptors.map(({ sourcePath, fileName }) => sourcePath instanceof URL ? copyRemote(sourcePath, fileName) : copyLocal(sourcePath, fileName, options)));
}
exports.copyFiles = copyFiles;
async function copyRemote(sourcePath, fileName) {
    return new Promise((resolve, reject) => {
        https
            .get(sourcePath, response => {
            if (response.statusCode && (response.statusCode < 200 || response.statusCode > 299)) {
                reject(new Error('Failed to load page, status code: ' + response.statusCode));
            }
            let content = '';
            response.on('data', (chunk) => (content += chunk));
            response.on('end', () => {
                fs.mkdirSync(path.dirname(fileName), { recursive: true });
                fs.writeFileSync(fileName, content);
                resolve();
            });
        })
            .on('error', e => {
            reject(e);
        });
    });
}
async function copyLocal(sourcePath, fileName, options) {
    fs.mkdirSync(path.dirname(fileName), { recursive: true });
    if (path.extname(sourcePath) === '.mu') {
        const template = handlebars_1.compile(fs.readFileSync(sourcePath, { encoding: 'utf8' }));
        fs.writeFileSync(fileName, template(options));
    }
    else {
        fs.copyFileSync(sourcePath, fileName);
    }
}

"use strict";
/*!
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCatalogueModule = exports.buildScaffold = exports.shouldBuildScaffold = void 0;
const cli_ux_1 = require("cli-ux");
const execa = require("execa");
const fs = require("fs");
const path = require("path");
const rm = require("rimraf");
const utils_1 = require("../utils/");
async function shouldBuildScaffold(projectDir, buildScaffold, force = false) {
    if (buildScaffold) {
        await checkForEmptyDir(projectDir, force);
        return true;
    }
    if (fs.existsSync(path.resolve(projectDir, 'package.json'))) {
        return false;
    }
    cli_ux_1.default.log(`The target directory (${projectDir}) does not contain a \`package.json.\``);
    if (await cli_ux_1.default.confirm('Should a new `nest.js` project be initialized in the target directory? (y|n)')) {
        await checkForEmptyDir(projectDir, force);
        return true;
    }
    cli_ux_1.default.info('➡️ Cancelling `init` because a valid `package.json` is required to run.');
    return cli_ux_1.default.exit(13);
}
exports.shouldBuildScaffold = shouldBuildScaffold;
async function checkForEmptyDir(projectDir, force) {
    if (fs.readdirSync(projectDir).length !== 0) {
        const dirString = projectDir === '.' ? 'this directory' : `"${projectDir}"`;
        const question = `Directory is not empty. Creating the scaffold will fail if there are conflicting files. Should ALL files in ${dirString} be removed? (y|n)`;
        if (force || (await cli_ux_1.default.confirm(question))) {
            rm.sync(`${projectDir}/{*,.*}`);
        }
    }
}
async function buildScaffold(projectDir, verbose, addCds) {
    cli_ux_1.default.action.start('Building application scaffold');
    const options = {
        cwd: projectDir,
        stdio: verbose ? 'inherit' : 'ignore'
    };
    await execa('npx', ['-p', '@nestjs/cli', 'nest', 'new', '.', '--skip-install', '--package-manager', 'npm'], options);
    fs.unlinkSync(path.resolve(projectDir, 'README.md'));
    modifyMainTs(path.resolve(projectDir, 'src', 'main.ts'));
    modifyTsconfigBuildJson(path.resolve(projectDir, 'tsconfig.build.json'));
    modifyTsconfigJson(path.resolve(projectDir, 'tsconfig.json'));
    if (addCds) {
        addCatalogueModule(path.resolve(projectDir, 'src', 'app.module.ts'));
    }
    cli_ux_1.default.action.stop();
}
exports.buildScaffold = buildScaffold;
function modifyMainTs(pathToMainTs) {
    const mainTs = fs.readFileSync(pathToMainTs, { encoding: 'utf8' });
    const modifiedListen = '.listen(process.env.PORT || 3000)';
    const modifiedMainTs = mainTs.replace('.listen(3000)', modifiedListen);
    if (!modifiedMainTs.includes(modifiedListen)) {
        utils_1.recordWarning('Could not set listening port to `process.env.PORT`', 'in file `app.module.ts`. Please adjust manually.');
    }
    else {
        try {
            fs.writeFileSync(pathToMainTs, modifiedMainTs);
        }
        catch (err) {
            utils_1.recordWarning('Could not set listening port to `process.env.PORT`', 'in file `app.module.ts`. Please adjust manually.');
        }
    }
}
function modifyTsconfigBuildJson(pathToTsconfigBuildJson) {
    const tsconfigBuildJson = fs.readFileSync(pathToTsconfigBuildJson, { encoding: 'utf8' });
    const jsonObj = JSON.parse(tsconfigBuildJson);
    if (jsonObj.exclude) {
        jsonObj.exclude = [...jsonObj.exclude, 'deployment'];
    }
    try {
        fs.writeFileSync(pathToTsconfigBuildJson, JSON.stringify(jsonObj, null, 2));
    }
    catch (err) {
        utils_1.recordWarning('Could not exclude deployment`', 'in file `tsconfig.build.json`. Please adjust manually.');
    }
}
function modifyTsconfigJson(pathToTsconfigJson) {
    const tsconfigJson = fs.readFileSync(pathToTsconfigJson, { encoding: 'utf8' });
    const jsonObj = JSON.parse(tsconfigJson);
    if (jsonObj.compilerOptions) {
        jsonObj.compilerOptions = Object.assign(Object.assign({}, jsonObj.compilerOptions), { allowJs: true });
    }
    try {
        fs.writeFileSync(pathToTsconfigJson, JSON.stringify(jsonObj, null, 2));
    }
    catch (err) {
        utils_1.recordWarning('Could not add compiler option "allowJs": true`', 'in file `tsconfig.json`. Please adjust manually.');
    }
}
function addCatalogueModule(pathToAppModuleTs) {
    const appModuleTs = fs.readFileSync(pathToAppModuleTs, { encoding: 'utf8' });
    const moduleName = 'CatalogueModule';
    const importToAdd = `import { ${moduleName} } from './catalogue/catalogue.module';`;
    const modifiedAppModuleTs = appModuleTs
        .replace('@Module', [importToAdd, '@Module'].join('\n\n'))
        .replace('imports: []', `imports: [${moduleName}]`);
    if (!modifiedAppModuleTs.includes(`imports: [${moduleName}]`)) {
        utils_1.recordWarning(`Could not add module ${moduleName} to \`app.module.ts\`. Please add manually.`);
    }
    else {
        fs.writeFileSync(pathToAppModuleTs, modifiedAppModuleTs);
    }
}
exports.addCatalogueModule = addCatalogueModule;

"use strict";
/*!
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.installDependencies = exports.modifyPackageJson = exports.parsePackageJson = void 0;
const execa = require("execa");
const fs = require("fs");
const path = require("path");
const utils_1 = require("../utils/");
const jest_config_1 = require("./jest-config");
const frontendTestScripts = {
    scripts: {
        'ci-frontend-unit-test': 'echo "Test your application and write results in a JUnit format to `s4hana_pipeline/reports/frontend-unit/` and coverage in a cobertura format to `s4hana_pipeline/reports/coverage/frontend-unit/`"',
        'ci-e2e': 'echo "Test your application and write results in a JUnit format to `s4hana_pipeline/reports/e2e/`"'
    }
};
const cdsChanges = {
    scripts: {
        'cds-build': 'cds build/all',
        'cds-deploy': 'cds deploy',
        'ci-build': 'npm run cds-deploy && npm run cds-build && npm run build',
        'ci-package': 'sap-cloud-sdk package --include="package.json,package-lock.json,index.js,dist/**/*,db/**/*,srv/**/*,.cdsrc.json"'
    },
    devDependencies: ['sqlite3'],
    dependencies: ['@sap/cds', '@sap/cds-dk']
};
const scaffoldProjectPackageJson = {
    scripts: {
        'deploy': 'npm run build && sap-cloud-sdk package && cf push',
        'ci-build': 'npm run build',
        'ci-package': 'sap-cloud-sdk package --ci',
        'ci-integration-test': 'jest --ci --config ./test/jest-e2e.json',
        'ci-backend-unit-test': 'jest --ci'
    },
    devDependencies: ['jest-junit', '@sap-cloud-sdk/test-util', '@sap-cloud-sdk/cli'],
    dependencies: ['@sap-cloud-sdk/core'],
    jest: jest_config_1.getJestConfig(true)
};
const existingProjectPackageJson = {
    scripts: {
        'ci-build': 'echo "Use this to compile or minify your application"',
        'ci-package': 'sap-cloud-sdk package --include="package.json,package-lock.json,index.js,dist/**/*"',
        'ci-integration-test': 'echo "Test your application and write results in a JUnit format to `s4hana_pipeline/reports/backend-integration/` and coverage in a cobertura format to `s4hana_pipeline/reports/coverage/backend-integration/`"',
        'ci-backend-unit-test': 'echo "Test your application and write results in a JUnit format to `s4hana_pipeline/reports/backend-unit/` and coverage in a cobertura format to `s4hana_pipeline/reports/coverage/backend-unit/`"'
    },
    devDependencies: ['@sap-cloud-sdk/test-util', '@sap-cloud-sdk/cli'],
    dependencies: ['@sap-cloud-sdk/core']
};
async function parsePackageJson(projectDir) {
    try {
        return JSON.parse(fs.readFileSync(path.resolve(projectDir, 'package.json'), {
            encoding: 'utf8'
        }));
    }
    catch (error) {
        throw new Error(`Your package.json does not contain valid JSON. Please repair or delete it. ${error}`);
    }
}
exports.parsePackageJson = parsePackageJson;
function findScriptConflicts(originalScripts, scriptsToBeAdded) {
    return originalScripts ? Object.keys(scriptsToBeAdded).filter(name => Object.keys(originalScripts).includes(name)) : [];
}
async function getPackageJsonChanges(isScaffold, frontendScripts, addCds) {
    const changes = [isScaffold ? scaffoldProjectPackageJson : existingProjectPackageJson];
    if (frontendScripts) {
        changes.push(frontendTestScripts);
    }
    if (addCds) {
        changes.push(cdsChanges);
    }
    const merged = changes.reduce((mergedChanges, change) => {
        Object.entries(change).forEach(([key, value]) => {
            const newValue = Object.assign(Object.assign({}, mergedChanges[key]), value);
            mergedChanges[key] = Array.isArray(value) ? Object.values(newValue) : newValue;
        });
        return mergedChanges;
    }, {});
    return Object.assign(Object.assign({}, merged), { dependencies: await addDependencyVersions(merged.dependencies), devDependencies: await addDependencyVersions(merged.devDependencies) });
}
function mergePackageJson(originalPackageJson, changes) {
    const adjustedPackageJson = Object.assign(Object.assign({}, originalPackageJson), { scripts: Object.assign(Object.assign({}, originalPackageJson.scripts), changes.scripts), dependencies: Object.assign(Object.assign({}, changes.dependencies), originalPackageJson.dependencies), devDependencies: Object.assign(Object.assign({}, changes.devDependencies), originalPackageJson.devDependencies) });
    if (changes.jest) {
        adjustedPackageJson.jest = Object.assign(Object.assign({}, originalPackageJson.jest), changes.jest);
    }
    return adjustedPackageJson;
}
async function modifyPackageJson({ projectDir, isScaffold = false, frontendScripts = false, force = false, addCds = false }) {
    const originalPackageJson = await parsePackageJson(projectDir);
    const changes = await getPackageJsonChanges(isScaffold, frontendScripts, addCds);
    const conflicts = findScriptConflicts(originalPackageJson.scripts, changes.scripts);
    if (conflicts.length && !force) {
        throw new Error(conflicts.length > 1
            ? `Scripts with the names "${conflicts.join('", "')}" already exist. If you want to overwrite them, rerun the command with \`--force\`.`
            : `A script with the name "${conflicts.join('", "')}" already exists. If you want to overwrite it, rerun the command with \`--force\`.`);
    }
    fs.writeFileSync(path.resolve(projectDir, 'package.json'), JSON.stringify(mergePackageJson(originalPackageJson, changes), null, 2));
}
exports.modifyPackageJson = modifyPackageJson;
async function addDependencyVersions(dependencies = []) {
    const versions = await Promise.all(dependencies.map(dependency => getVersionOfDependency(dependency)));
    return dependencies.reduce((result, dependency, index) => (Object.assign(Object.assign({}, result), { [dependency]: versions[index] })), {});
}
async function getVersionOfDependency(dependency) {
    try {
        const args = ['view', dependency, 'version'];
        const version = dependency.includes('@sap/') ? execa('npm', [...args, '--registry', 'https://npm.sap.com']) : execa('npm', args);
        return `^${(await version).stdout}`;
    }
    catch (e) {
        utils_1.recordWarning(`Could not find version information for dependency ${dependency}.`, 'Instead `LATEST` was used as fallback.');
        return 'latest';
    }
}
async function installDependencies(projectDir, verbose) {
    return execa('npm', ['install'], {
        cwd: projectDir,
        stdio: verbose ? 'inherit' : 'ignore'
    });
}
exports.installDependencies = installDependencies;
